import os
import fitz  # PyMuPDF
import docx
import google.generativeai as genai
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from dotenv import load_dotenv
from pydantic import BaseModel

# Load environment variables from .env file
load_dotenv()

app = FastAPI()

# Mount the 'frontend' directory to serve static files like CSS and JS
app.mount("/frontend", StaticFiles(directory="frontend"), name="frontend")

@app.get("/")
async def read_index():
    return FileResponse('frontend/index.html')


class PresentationRequest(BaseModel):
    folder_path: str

# An endpoint to demonstrate that the API key is loaded (for testing purposes)
# In a real app, you would NOT expose the key like this.
@app.get("/check-key")
def check_api_key():
    api_key = os.getenv("GEMINI_API_KEY")
    if api_key and api_key != "YOUR_API_KEY_HERE":
        return {"status": "API Key is loaded successfully."}
    else:
        return {"status": "API Key not found or is set to the default placeholder."}


def generate_html_from_summary(summary_path: str, output_folder: str):
    """
    Uses the Gemini API to generate an HTML presentation from a Markdown summary.
    """
    print(f"Reading summary file: {summary_path}")
    with open(summary_path, "r", encoding="utf-8") as f:
        summary_content = f.read()

    print("Sending summary to Gemini for HTML generation...")
    model = genai.GenerativeModel('gemini-pro')

    prompt = """You are a web designer. Based on the following Markdown summary, create a complete, single-page, responsive HTML presentation. 
              The HTML should be modern and visually appealing. It must include:

              1. A `<head>` section with a title and a link to a `style.css` file.

              2. A `<body>` containing:

                 a. A `<header>` with the main project title.

                 b. A `<nav>` bar with anchor links to the different sections of the page.

                 c. A `<main>` section with the content from the Markdown, divided into logical `<section>` tags, each with a unique ID for the nav links.

                 d. A `<footer>` with the text 'Generated by Epirus Showcase Agent'.

              3. Provide the CSS code for the `style.css` file separately, enclosed in a ```css code block. The CSS should be modern and ensure the page is responsive.

              Here is the Markdown content:\n\n---\n\n""" + summary_content

    try:
        response = model.generate_content(prompt)
        # The response should contain both HTML and CSS. We need to parse them.
        full_response_text = response.text
        
        # Extract CSS
        css_start = full_response_text.find("```css")
        css_end = full_response_text.rfind("```")
        css_code = ""
        if css_start != -1 and css_end != -1 and css_start < css_end:
            css_code = full_response_text[css_start + 6 : css_end].strip()
            # The HTML is everything before the CSS block
            html_code = full_response_text[:css_start].strip()
        else:
            # If no CSS block is found, assume the whole response is HTML
            html_code = full_response_text.strip()

        # Clean up potential markdown formatting from the HTML code block
        if html_code.startswith("```html"):
            html_code = html_code[7:]
        if html_code.endswith("```"):
            html_code = html_code[:-3]

        html_path = os.path.join(output_folder, "index.html")
        with open(html_path, "w", encoding="utf-8") as f:
            f.write(html_code)
        print(f"HTML presentation successfully generated and saved to {html_path}")

        if css_code:
            css_path = os.path.join(output_folder, "style.css")
            with open(css_path, "w", encoding="utf-8") as f:
                f.write(css_code)
            print(f"CSS stylesheet successfully generated and saved to {css_path}")

    except Exception as e:
        print(f"An error occurred while generating the HTML: {e}")

def generate_summary_with_gemini(content: str, output_folder: str):
    """
    Uses the Gemini API to generate a summary and then triggers HTML generation.
    """
    print("Sending content to Gemini for summarization...")
    model = genai.GenerativeModel('gemini-pro')
    
    prompt = f"""Based on the following text extracted from various project documents, create a comprehensive and well-structured summary in Markdown format. 
The summary should identify and highlight key information such as: Project Title, Budget, Timeline, Key Stakeholders, Objectives, and a general Technical Description. 
Structure the output with clear headings and bullet points. The file should be named 'summary.md'.

---

{content}
"""

    try:
        response = model.generate_content(prompt)
        summary = response.text
        
        summary_path = os.path.join(output_folder, "summary.md")
        with open(summary_path, "w", encoding="utf-8") as f:
            f.write(summary)
        print(f"Summary successfully generated and saved to {summary_path}")
        
        # Now, generate the HTML from this summary
        generate_html_from_summary(summary_path, output_folder)

    except Exception as e:
        print(f"An error occurred while communicating with the Gemini API: {e}")


def read_file_content(file_path: str) -> str | None:
    """
    Reads the content of a file based on its extension.
    Currently supports: .txt, .md
    """
    _, extension = os.path.splitext(file_path)
    extension = extension.lower()

    if extension in [".txt", ".md"]:
        with open(file_path, "r", encoding="utf-8") as f:
            return f.read()
    else:
        print(f"Skipping unsupported file type: {file_path}")
        return None


def process_folder(folder_path: str):
    """
    Recursively walks through a folder, reads supported files,
    and triggers the summary and presentation generation.
    """
    print(f"Starting to process folder: {folder_path}")
    all_content = []

    for root, _, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            content = read_file_content(file_path)
            if content:
                # Add a separator to distinguish between files
                all_content.append(f"--- Content from {file} ---\n{content}")

    if not all_content:
        print("No supported files (.txt, .md) found in the provided folder.")
        return

    print(f"Found and read {len(all_content)} supported files.")
    combined_content = "\n\n".join(all_content)

    # The generated presentation files (index.html, style.css) will be saved in the 'frontend'
    # folder, overwriting the existing ones, so they can be served immediately.
    output_folder = "frontend"
    generate_summary_with_gemini(combined_content, output_folder)


@app.post("/create-presentation")
async def create_presentation(request: PresentationRequest):
    """
    This endpoint receives a folder path, processes all the files within it,
    and will eventually generate a presentation.
    """
    if not os.path.isdir(request.folder_path):
        return {"error": "Invalid folder path provided."}, 400

    process_folder(request.folder_path)
    
    return {"status": "Processing started.", "folder_path": request.folder_path}


# According to tech_stack.txt, we will use uvicorn to run this.
# To run the server, you would use the command in your terminal:
# .\.venv\Scripts\activate
# uvicorn main:app --reload